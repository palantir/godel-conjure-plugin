// Copyright (c) 2018 Palantir Technologies. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package integration_test

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"

	"github.com/nmiyake/pkg/dirs"
	"github.com/palantir/godel-conjure-plugin/v6/internal/tempfilecreator"
	"github.com/palantir/godel/v2/framework/pluginapitester"
	"github.com/palantir/godel/v2/pkg/products"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestConjurePlugin(t *testing.T) {
	const (
		conjureSpecYML = `
types:
  definitions:
    default-package: com.palantir.conjure.test.api
    objects:
      TestCase:
        fields:
          name: string
      TestUnion:
        union:
          testCase: TestCase
`
		conjureSpecJSON = `
{
  "version" : 1,
  "errors" : [ ],
  "types" : [ {
    "type" : "object",
    "object" : {
      "typeName" : {
        "name" : "TestCase",
        "package" : "com.palantir.conjure.test.api"
      },
      "fields" : [ {
        "fieldName" : "name",
        "type" : {
          "type" : "primitive",
          "primitive" : "STRING"
        }
      } ]
    }
  } ],
  "services" : [ ]
}
`
		yamlDir              = "yamlDir"
		conjureYMLSubstitute = `
version: 1
projects:
  project-1:
    accept-funcs: true
    output-dir: conjure-output
    ir-locator: ` + yamlDir + `
  project-2:
    output-dir: conjure-output2
    ir-locator:
      type: remote
      locator: SUBSTITUTE_URL
`
	)

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		_, _ = fmt.Fprint(w, conjureSpecJSON)
	}))
	defer ts.Close()

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := filepath.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()
	err = os.MkdirAll(filepath.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	conjureYML := strings.Replace(conjureYMLSubstitute, "SUBSTITUTE_URL", ts.URL, -1)
	err = os.WriteFile(filepath.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
	require.NoError(t, err)

	err = os.WriteFile(filepath.Join(ymlDir, "conjure.yml"), []byte(conjureSpecYML), 0644)
	require.NoError(t, err)

	outputBuf := &bytes.Buffer{}
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
	defer runPluginCleanup()
	require.NoError(t, err, outputBuf.String())

	for _, outputName := range []string{"conjure-output", "conjure-output2"} {
		contentBytes, err := os.ReadFile(filepath.Join(projectDir, outputName, "conjure", "test", "api", "structs.conjure.go"))
		require.NoError(t, err)
		wantContent := `// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type TestCase struct {
	Name string ` + "`" + `json:"name"` + "`" + `
}

func (o TestCase) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TestCase) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
`
		assert.Equal(t, wantContent, string(contentBytes), "Got:\n%s", string(contentBytes))
	}

	for _, outputName := range []string{"conjure-output"} {
		contentBytes, err := os.ReadFile(filepath.Join(projectDir, outputName, "conjure", "test", "api", "unions.conjure.go"))
		require.NoError(t, err)
		wantContent := `// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type TestUnion struct {
	typ      string
	testCase *TestCase
}

type testUnionDeserializer struct {
	Type     string    ` + "`" + `json:"type"` + "`" + `
	TestCase *TestCase ` + "`" + `json:"testCase"` + "`" + `
}

func (u *testUnionDeserializer) toStruct() TestUnion {
	return TestUnion{typ: u.Type, testCase: u.TestCase}
}

func (u *TestUnion) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "testCase":
		if u.testCase == nil {
			return nil, fmt.Errorf("field \"testCase\" is required")
		}
		return struct {
			Type     string   ` + "`" + `json:"type"` + "`" + `
			TestCase TestCase ` + "`" + `json:"testCase"` + "`" + `
		}{Type: "testCase", TestCase: *u.testCase}, nil
	}
}

func (u TestUnion) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TestUnion) UnmarshalJSON(data []byte) error {
	var deser testUnionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "testCase":
		if u.testCase == nil {
			return fmt.Errorf("field \"testCase\" is required")
		}
	}
	return nil
}

func (u TestUnion) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TestUnion) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TestUnion) AcceptFuncs(testCaseFunc func(TestCase) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in TestUnion type")
		}
		return unknownFunc(u.typ)
	case "testCase":
		if u.testCase == nil {
			return fmt.Errorf("field \"testCase\" is required")
		}
		return testCaseFunc(*u.testCase)
	}
}

func (u *TestUnion) TestCaseNoopSuccess(_ TestCase) error {
	return nil
}

func (u *TestUnion) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TestUnion) Accept(v TestUnionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "testCase":
		if u.testCase == nil {
			return fmt.Errorf("field \"testCase\" is required")
		}
		return v.VisitTestCase(*u.testCase)
	}
}

type TestUnionVisitor interface {
	VisitTestCase(v TestCase) error
	VisitUnknown(typeName string) error
}

func (u *TestUnion) AcceptWithContext(ctx context.Context, v TestUnionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "testCase":
		if u.testCase == nil {
			return fmt.Errorf("field \"testCase\" is required")
		}
		return v.VisitTestCaseWithContext(ctx, *u.testCase)
	}
}

type TestUnionVisitorWithContext interface {
	VisitTestCaseWithContext(ctx context.Context, v TestCase) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTestUnionFromTestCase(v TestCase) TestUnion {
	return TestUnion{typ: "testCase", testCase: &v}
}
`
		assert.Equal(t, wantContent, string(contentBytes), "Got:\n%s", string(contentBytes))
	}
}

func TestConjurePluginSetsExtensions(t *testing.T) {
	const (
		conjureSpecYML = `
types:
  definitions:
    default-package: com.palantir.conjure.test.api
    objects:
      TestCase:
        fields:
          name: string
`
		yamlDir    = "yamlDir"
		conjureYML = `
version: 2
projects:
  project-1:
    ir-locator: ` + yamlDir + `
    extensions:
      test-key: test-value
      test-key-map:
        map-key: map-value
        map-key-2: 2
`
	)

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := filepath.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()
	err = os.MkdirAll(filepath.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	err = os.WriteFile(filepath.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
	require.NoError(t, err)

	err = os.WriteFile(filepath.Join(ymlDir, "conjure.yml"), []byte(conjureSpecYML), 0644)
	require.NoError(t, err)

	// start a server that listens for PUT calls that end in ".conjure.json" and then records the value to the variable
	var gotConjureIRBytes []byte
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPut {
			return
		}
		if !strings.HasSuffix(r.URL.Path, ".conjure.json") {
			return
		}
		bodyBytes, err := io.ReadAll(r.Body)
		defer func() {
			_ = r.Body.Close()
		}()
		require.NoError(t, err)
		gotConjureIRBytes = bodyBytes
	}))
	defer ts.Close()

	// perform publish
	outputBuf := &bytes.Buffer{}
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure-publish", []string{
		"--group-id=com.palantir.test-group",
		"--repository=test-repo",
		"--url=" + ts.URL,
		"--username=test-username",
		"--password=test-password",
	}, projectDir, false, outputBuf)
	defer runPluginCleanup()
	require.NoError(t, err, outputBuf.String())

	// verify that published IR matches expected value and includes the "extensions" block
	assert.Equal(t, `{
  "version" : 1,
  "errors" : [ ],
  "types" : [ {
    "type" : "object",
    "object" : {
      "typeName" : {
        "name" : "TestCase",
        "package" : "com.palantir.conjure.test.api"
      },
      "fields" : [ {
        "fieldName" : "name",
        "type" : {
          "type" : "primitive",
          "primitive" : "STRING"
        }
      } ]
    }
  } ],
  "services" : [ ],
  "extensions" : {
    "test-key" : "test-value",
    "test-key-map" : {
      "map-key" : "map-value",
      "map-key-2" : 2
    }
  }
}`, string(gotConjureIRBytes))
}

func TestConjurePluginVerify(t *testing.T) {
	const (
		conjureSpecYML = `
types:
  definitions:
    default-package: com.palantir.base.api
    objects:
      BaseType:
        fields:
          id: string
`
		yamlDir = "yamlDir"
	)

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := filepath.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()

	err = os.MkdirAll(filepath.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	err = os.WriteFile(filepath.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(`
version: 1
projects:
  project-1:
    output-dir: conjure
    ir-locator: `+yamlDir+`
`), 0644)
	require.NoError(t, err)

	err = os.WriteFile(filepath.Join(ymlDir, "conjure.yml"), []byte(conjureSpecYML), 0644)
	require.NoError(t, err)

	outputBuf := &bytes.Buffer{}
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
	defer runPluginCleanup()
	require.NoError(t, err, outputBuf.String())

	outputBuf = &bytes.Buffer{}
	_, err = pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", []string{"verify"}, projectDir, false, outputBuf)
	require.NoError(t, err, outputBuf.String())

	structsFile := filepath.Join("conjure", "base", "api", "structs.conjure.go")
	err = os.WriteFile(filepath.Join(projectDir, structsFile), []byte("package api"), 0644)
	require.NoError(t, err, "failed to change generated file")

	outputBuf = &bytes.Buffer{}
	_, err = pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", []string{"--verify"}, projectDir, false, outputBuf)
	assert.Error(t, err, "modified file did not trigger verify fail")
	stdout := outputBuf.String()
	assert.True(t, strings.Contains(stdout, structsFile+": checksum changed"), "Unexpected standard out: %s", stdout)
}

func TestConjurePluginPublish(t *testing.T) {
	const (
		conjureSpecYML = `
types:
  definitions:
    default-package: com.palantir.conjure.test.api
    objects:
      TestCase:
        fields:
          name: string
`
		yamlDir    = "yamlDir"
		conjureYML = `
version: 1
projects:
  project-1:
    output-dir: conjure-output
    ir-locator: ` + yamlDir + `
`
		asset1 = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
    printf '%s\n' '{ "type": "conjure-ir-extensions-provider" }'
    exit 0
fi

printf '%s\n' '{}'
exit 0
`
	)

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))
	defer ts.Close()

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := filepath.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()
	err = os.MkdirAll(filepath.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	err = os.WriteFile(filepath.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
	require.NoError(t, err)

	err = os.WriteFile(filepath.Join(ymlDir, "conjure.yml"), []byte(conjureSpecYML), 0644)
	require.NoError(t, err)

	asset1File := tempfilecreator.MustWriteBytesToTempFile([]byte(asset1))
	require.NoError(t, os.Chmod(asset1File, 0700))

	outputBuf := &bytes.Buffer{}
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure-publish", []string{
		"--dry-run",
		"--assets=" + asset1File,
		"--group-id=com.palantir.test-group",
		"--repository=test-repo",
		"--url=" + ts.URL,
		"--username=test-username",
		"--password=test-password",
	}, projectDir, false, outputBuf)
	defer runPluginCleanup()
	require.NoError(t, err, outputBuf.String())

	lines := strings.Split(outputBuf.String(), "\n")
	assert.Equal(t, 3, len(lines), "Expected output to have 3 lines:\n%s", outputBuf.String())

	wantRegexp := regexp.QuoteMeta("[DRY RUN]") + " Uploading .*?" + regexp.QuoteMeta(".conjure.json") + " to " + regexp.QuoteMeta(ts.URL+"/artifactory/test-repo/com/palantir/test-group/project-1/") + ".*?" + regexp.QuoteMeta("/project-1-") + ".*?" + regexp.QuoteMeta(".conjure.json")
	assert.Regexp(t, wantRegexp, lines[0])

	wantRegexp = regexp.QuoteMeta("[DRY RUN]") + " Uploading to " + regexp.QuoteMeta(ts.URL+"/artifactory/test-repo/com/palantir/test-group/") + ".*?" + regexp.QuoteMeta(".pom")
	assert.Regexp(t, wantRegexp, lines[1])
}

func TestConjurePluginPublishAssetSpec(t *testing.T) {
	const (
		yamlDir    = "yamlDir"
		conjureYML = `
version: 1
projects:
  project-1: { }
`
		assetDoesNotReturnValidJsonObject = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
    printf '%s\n' '{ "type": "conjure-ir-extensions-provider" }'
    exit 0
fi

printf '%s\n' '"not a json object"'
exit 0
`
		assetDoesNotReturnValidAssetInfoType = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
	touch /Volumes/git/ran-invalid-info
    printf '%s\n' '{ "Type": "conjure-ir-extensions-provider" }'
    exit 0
fi

printf '%s\n' 'unreachable: something is wrong if the asset was called with more anything other than _assetInfo as the only arg'
exit 1
`
		assetDoesNotReturnValidAssetInfoJson = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
	touch /Volumes/git/ran-invalid-info
    printf '%s\n' 'invalid json'
    exit 0
fi

printf '%s\n' 'unreachable: something is wrong if the asset was called with more anything other than _assetInfo as the only arg'
exit 1
`
		assetDoesNotReturnValidAssetInfoJsonObject = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
	touch /Volumes/git/ran-invalid-info
    printf '%s\n' '"invalid json object"'
    exit 0
fi

printf '%s\n' 'unreachable: something is wrong if the asset was called with more anything other than _assetInfo as the only arg'
exit 1
`
		assetDoesNotHaveValidType = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
    printf '%s\n' '{ "type": "valid type that follows the spec but is not supported yet so it should just not be called again and everything will exit OK" }'
    exit 0
fi

printf '%s\n' 'test failed: should be unreachable'
exit 1
`
	)

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := filepath.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()
	err = os.MkdirAll(filepath.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	err = os.WriteFile(filepath.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
	require.NoError(t, err)

	for _, assetFileContent := range []string{
		assetDoesNotReturnValidJsonObject,
		assetDoesNotReturnValidAssetInfoType,
		assetDoesNotReturnValidAssetInfoJson,
		assetDoesNotReturnValidAssetInfoJsonObject,
		assetDoesNotHaveValidType,
	} {
		assetFile := tempfilecreator.MustWriteBytesToTempFile([]byte(assetFileContent))
		require.NoError(t, os.Chmod(assetFile, 0700))

		err = innerTestConjurePluginPublishAssetSpec(pluginapitester.NewPluginProvider(pluginPath), assetFile, projectDir)
		assert.Error(t, err)
	}

}

func innerTestConjurePluginPublishAssetSpec(pluginProvider pluginapitester.PluginProvider, assetFile, projectDir string) error {
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginProvider, nil, "conjure-publish", []string{
		"--dry-run",
		"--assets=" + assetFile,
		"--group-id=com.palantir.test-group",
		"--repository=test-repo",
		"--url=unreachable.palantir.com",
		"--username=test-username",
		"--password=test-password",
	}, projectDir, false, &bytes.Buffer{})
	defer runPluginCleanup()
	return err
}

func TestConjurePluginSetsExtensionsWithPublishAsset(t *testing.T) {
	const (
		conjureSpecYML = `
types:
  definitions:
    default-package: com.palantir.conjure.test.api
    objects:
      TestCase:
        fields:
          name: string
`
		yamlDir    = "yamlDir"
		conjureYML = `
version: 2
projects:
  project-1:
    ir-locator: ` + yamlDir + `
    extensions:
      original-config-key: original-config-value
      common-key: original-config-value
`
		assetFileContent = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
    printf '%s\n' '{ "type": "conjure-ir-extensions-provider" }'
    exit 0
fi

printf '%s\n' '{"common-key": "asset-value", "asset-key": 7}'
exit 0
`
	)

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := filepath.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()
	err = os.MkdirAll(filepath.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	err = os.WriteFile(filepath.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
	require.NoError(t, err)

	err = os.WriteFile(filepath.Join(ymlDir, "conjure.yml"), []byte(conjureSpecYML), 0644)
	require.NoError(t, err)

	// start a server that listens for PUT calls that end in ".conjure.json" and then records the value to the variable
	var gotConjureIRBytes []byte
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPut {
			return
		}
		if !strings.HasSuffix(r.URL.Path, ".conjure.json") {
			return
		}
		bodyBytes, err := io.ReadAll(r.Body)
		defer func() {
			_ = r.Body.Close()
		}()
		require.NoError(t, err)
		gotConjureIRBytes = bodyBytes
	}))
	defer ts.Close()

	assetFile := tempfilecreator.MustWriteBytesToTempFile([]byte(assetFileContent))
	require.NoError(t, os.Chmod(assetFile, 0700))

	// perform publish
	outputBuf := &bytes.Buffer{}
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure-publish", []string{
		"--group-id=com.palantir.test-group",
		"--repository=test-repo",
		"--assets=" + assetFile,
		"--url=" + ts.URL,
		"--username=test-username",
		"--password=test-password",
	}, projectDir, false, outputBuf)
	defer runPluginCleanup()
	require.NoError(t, err, outputBuf.String())

	// verify that published IR matches expected value and includes the "extensions" block
	// that is the result of applying the original map with the asset map
	assert.Equal(t, `{
	"errors": [],
	"extensions": {
		"asset-key": 7,
		"common-key": "asset-value",
		"original-config-key": "original-config-value"
	},
	"services": [],
	"types": [
		{
			"object": {
				"fields": [
					{
						"fieldName": "name",
						"type": {
							"primitive": "STRING",
							"type": "primitive"
						}
					}
				],
				"typeName": {
					"name": "TestCase",
					"package": "com.palantir.conjure.test.api"
				}
			},
			"type": "object"
		}
	],
	"version": 1
}`, string(gotConjureIRBytes))
}

func TestUpgradeConfig(t *testing.T) {
	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)
	pluginProvider := pluginapitester.NewPluginProvider(pluginPath)

	pluginapitester.RunUpgradeConfigTest(t,
		pluginProvider,
		nil,
		[]pluginapitester.UpgradeConfigTestCase{
			{
				Name: "legacy config fails to upgrade",
				ConfigFiles: map[string]string{
					"godel/config/conjure.yml": `
conjure-projects:
  # comment
  project-1:
    project-file: ./conjure-project.yml
  project-2:
    project-file: foo/conjure-project.yml
  project-3:
    project-file: bar/conjure-project.yml
`,
				},
				Legacy:     true,
				WantError:  true,
				WantOutput: "Failed to upgrade configuration:\n\tgodel/config/conjure-plugin.yml: failed to upgrade configuration: v0 configuration is not supported\n",
			},
			{
				Name: "blank legacy config upgrade succeeds",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": ``,
				},
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": ``,
				},
				Legacy:     true,
				WantOutput: "",
			},
			{
				Name: "v0 config fails to upgrade",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `
conjure-projects:
  # comment
  project-1:
    project-file: ./conjure-project.yml
  project-2:
    project-file: foo/conjure-project.yml
  project-3:
    project-file: bar/conjure-project.yml
`,
				},
				WantError:  true,
				WantOutput: "Failed to upgrade configuration:\n\tgodel/config/conjure-plugin.yml: v0 configuration is not supported\n",
			},
			{
				Name: "blank v0 config upgrade succeeds",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": ``,
				},
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": ``,
				},
				WantOutput: "",
			},
			{
				Name: "v1 config with custom output-dir upgrades to v2 with escape valves",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: 1
projects:
  sls-health-api:
    output-dir: conjure
    ir-locator: https://publish.artifactory.com/artifactory/internal-conjure-release/com/palantir/spec/health-api/3.2.0/health-api-3.2.0.json
`,
				},
				WantOutput: "Upgraded configuration for conjure-plugin.yml\n",
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: "2"
projects:
  sls-health-api:
    output-dir: conjure
    ir-locator:
      type: auto
      locator: https://publish.artifactory.com/artifactory/internal-conjure-release/com/palantir/spec/health-api/3.2.0/health-api-3.2.0.json
    omit-top-level-project-dir: true
    skip-delete-generated-files: true
`,
				},
			},
			{
				Name: "v1 config matching v2 defaults upgrades to clean v2",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: 1
projects:
  myproject:
    output-dir: internal/generated/conjure/myproject
    ir-locator: https://example.com/ir.json
`,
				},
				WantOutput: "Upgraded configuration for conjure-plugin.yml\n",
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: "2"
projects:
  myproject:
    ir-locator:
      type: auto
      locator: https://example.com/ir.json
    skip-delete-generated-files: true
`,
				},
			},
			{
				Name: "v1 config with base internal/generated/conjure upgrades with escape valves",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: 1
projects:
  api:
    output-dir: internal/generated/conjure
    ir-locator: ./conjure/api.yml
`,
				},
				WantOutput: "Upgraded configuration for conjure-plugin.yml\n",
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: "2"
projects:
  api:
    ir-locator:
      type: auto
      locator: ./conjure/api.yml
    omit-top-level-project-dir: true
    skip-delete-generated-files: true
`,
				},
			},
			{
				Name: "v1 config where output-dir matches project name upgrades cleanly",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: 1
projects:
  mag-api:
    output-dir: mag-api
    ir-locator: ./conjure/mag-api.yml
`,
				},
				WantOutput: "Upgraded configuration for conjure-plugin.yml\n",
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: "2"
projects:
  mag-api:
    output-dir: .
    ir-locator:
      type: auto
      locator: ./conjure/mag-api.yml
    skip-delete-generated-files: true
`,
				},
			},
			{
				Name: "v2 config is validated and unchanged",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: 2
projects:
  sls-health-api:
    omit-top-level-project-dir:  true
    # comment
    output-dir: internal/generated/conjure
    ir-locator: https://publish.artifactory.com/artifactory/internal-conjure-release/com/palantir/spec/health-api/3.2.0/health-api-3.2.0.json
allow-conflicting-output-dirs: false
`,
				},
				WantOutput: "",
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: 2
projects:
  sls-health-api:
    omit-top-level-project-dir:  true
    # comment
    output-dir: internal/generated/conjure
    ir-locator: https://publish.artifactory.com/artifactory/internal-conjure-release/com/palantir/spec/health-api/3.2.0/health-api-3.2.0.json
allow-conflicting-output-dirs: false
`,
				},
			},
			{
				Name: "v1 config with conflicting output directories sets allow-conflicting-output-dirs",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: 1
projects:
  project-1:
    output-dir: shared-output
    ir-locator: https://example.com/project1.json
  project-2:
    output-dir: shared-output
    ir-locator: https://example.com/project2.json
`,
				},
				WantOutput: "Upgraded configuration for conjure-plugin.yml\n",
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: "2"
allow-conflicting-output-dirs: true
projects:
  project-1:
    output-dir: shared-output
    ir-locator:
      type: auto
      locator: https://example.com/project1.json
    omit-top-level-project-dir: true
    skip-delete-generated-files: true
  project-2:
    output-dir: shared-output
    ir-locator:
      type: auto
      locator: https://example.com/project2.json
    omit-top-level-project-dir: true
    skip-delete-generated-files: true
`,
				},
			},
			{
				Name: "v1 config with nested output directories sets allow-conflicting-output-dirs",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: 1
projects:
  parent-project:
    output-dir: parent
    ir-locator: https://example.com/parent.json
  child-project:
    output-dir: parent/child
    ir-locator: https://example.com/child.json
`,
				},
				WantOutput: "Upgraded configuration for conjure-plugin.yml\n",
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: "2"
allow-conflicting-output-dirs: true
projects:
  child-project:
    output-dir: parent/child
    ir-locator:
      type: auto
      locator: https://example.com/child.json
    omit-top-level-project-dir: true
    skip-delete-generated-files: true
  parent-project:
    output-dir: parent
    ir-locator:
      type: auto
      locator: https://example.com/parent.json
    omit-top-level-project-dir: true
    skip-delete-generated-files: true
`,
				},
			},
			{
				Name: "v1 config without conflicting output directories does not set allow-conflicting-output-dirs",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: 1
projects:
  project-1:
    output-dir: output1
    ir-locator: https://example.com/project1.json
  project-2:
    output-dir: output2
    ir-locator: https://example.com/project2.json
`,
				},
				WantOutput: "Upgraded configuration for conjure-plugin.yml\n",
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `version: "2"
projects:
  project-1:
    output-dir: output1
    ir-locator:
      type: auto
      locator: https://example.com/project1.json
    omit-top-level-project-dir: true
    skip-delete-generated-files: true
  project-2:
    output-dir: output2
    ir-locator:
      type: auto
      locator: https://example.com/project2.json
    omit-top-level-project-dir: true
    skip-delete-generated-files: true
`,
				},
			},
		},
	)
}

func TestConfigWarning(t *testing.T) {
	const (
		conjureSpecYML = `
types:
  definitions:
    default-package: com.palantir.conjure.test.api
    objects:
      TestCase:
        fields:
          name: string
      TestUnion:
        union:
          testCase: TestCase
`
		yamlDir    = "yamlDir"
		conjureYML = `
version: 1
projects:
  project-1:
    output-dir: conjure-output
    ir-locator: ` + yamlDir + `
  project-2:
    output-dir: conjure-output
    ir-locator: ` + yamlDir + `
  project-3:
    output-dir: conjure-output-2
    ir-locator: ` + yamlDir + `
  project-4:
    output-dir: conjure-output-2
    ir-locator: ` + yamlDir + `
`
	)

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := filepath.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()
	err = os.MkdirAll(filepath.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	err = ioutil.WriteFile(filepath.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
	require.NoError(t, err)

	err = ioutil.WriteFile(filepath.Join(ymlDir, "conjure.yml"), []byte(conjureSpecYML), 0644)
	require.NoError(t, err)

	outputBuf := &bytes.Buffer{}
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
	defer runPluginCleanup()
	require.NoError(t, err, outputBuf.String())

	assert.Equal(t, `[WARNING]: project "project-1" and "project-2" have the same output directory "conjure-output"
[WARNING]: project "project-2" and "project-1" have the same output directory "conjure-output"
[WARNING]: project "project-3" and "project-4" have the same output directory "conjure-output-2"
[WARNING]: project "project-4" and "project-3" have the same output directory "conjure-output-2"
`, outputBuf.String())
}

func TestSkipDeleteGeneratedFiles(t *testing.T) {
	const (
		conjureSpecYML = `
types:
  definitions:
    default-package: com.palantir.conjure.test.api
    objects:
      TestCase:
        fields:
          name: string
`
		yamlDir = "yamlDir"
	)

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	defer cleanup()

	ymlDir := filepath.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)

	err = os.MkdirAll(filepath.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)

	err = os.WriteFile(filepath.Join(ymlDir, "conjure.yml"), []byte(conjureSpecYML), 0644)
	require.NoError(t, err)

	t.Run("skip-delete-generated-files=false deletes old generated files", func(t *testing.T) {
		// Create config with skip-delete-generated-files: false (explicit)
		conjureYML := `version: 2
projects:
  test-project:
    output-dir: conjure-output
    omit-top-level-project-dir: true
    ir-locator: ` + yamlDir + `
    skip-delete-generated-files: false
`
		err = os.WriteFile(filepath.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
		require.NoError(t, err)

		// First generation
		outputBuf := &bytes.Buffer{}
		runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
		require.NoError(t, err, outputBuf.String())
		runPluginCleanup()

		// Verify file was generated
		generatedFilePath := filepath.Join(projectDir, "conjure-output", "conjure", "test", "api", "structs.conjure.go")
		originalContent, err := os.ReadFile(generatedFilePath)
		require.NoError(t, err)
		require.Contains(t, string(originalContent), "type TestCase struct")

		// Create an additional conjure file that should be deleted
		oldFilePath := filepath.Join(projectDir, "conjure-output", "conjure", "test", "api", "oldfile.conjure.go")
		err = os.WriteFile(oldFilePath, []byte("// This is an old generated file\npackage api"), 0644)
		require.NoError(t, err)

		// Modify the generated file to verify it gets regenerated
		err = os.WriteFile(generatedFilePath, []byte("// MODIFIED CONTENT"), 0644)
		require.NoError(t, err)

		// Second generation - should delete old files and regenerate
		outputBuf = &bytes.Buffer{}
		runPluginCleanup, err = pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
		require.NoError(t, err, outputBuf.String())
		runPluginCleanup()

		// Verify the old file was deleted
		_, err = os.Stat(oldFilePath)
		assert.True(t, os.IsNotExist(err), "expected old conjure file to be deleted")

		// Verify the modified file was regenerated (not preserved)
		newContent, err := os.ReadFile(generatedFilePath)
		require.NoError(t, err)
		assert.NotEqual(t, "// MODIFIED CONTENT", string(newContent), "expected file to be regenerated, not preserved")
		assert.Contains(t, string(newContent), "type TestCase struct", "expected regenerated file to contain correct content")
	})

	t.Run("skip-delete-generated-files=true preserves existing generated files", func(t *testing.T) {
		// Create config with skip-delete-generated-files: true
		conjureYML := `version: 2
projects:
  test-project:
    output-dir: conjure-output2
    omit-top-level-project-dir: true
    ir-locator: ` + yamlDir + `
    skip-delete-generated-files: true
`
		err = os.WriteFile(filepath.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
		require.NoError(t, err)

		// First generation
		outputBuf := &bytes.Buffer{}
		runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
		require.NoError(t, err, outputBuf.String())
		runPluginCleanup()

		// Verify file was generated
		generatedFilePath := filepath.Join(projectDir, "conjure-output2", "conjure", "test", "api", "structs.conjure.go")
		originalContent, err := os.ReadFile(generatedFilePath)
		require.NoError(t, err)
		require.Contains(t, string(originalContent), "type TestCase struct")

		// Create an additional conjure file that should NOT be deleted
		oldFilePath := filepath.Join(projectDir, "conjure-output2", "conjure", "test", "api", "oldfile.conjure.go")
		oldFileContent := "// This is an old generated file\npackage api"
		err = os.WriteFile(oldFilePath, []byte(oldFileContent), 0644)
		require.NoError(t, err)

		// Second generation - should NOT delete old files (v1 behavior)
		outputBuf = &bytes.Buffer{}
		runPluginCleanup, err = pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
		require.NoError(t, err, outputBuf.String())
		runPluginCleanup()

		// Verify the old file was NOT deleted (preserved)
		preservedContent, err := os.ReadFile(oldFilePath)
		require.NoError(t, err, "expected old conjure file to be preserved")
		assert.Equal(t, oldFileContent, string(preservedContent), "expected old file content to be unchanged")

		// Verify the main file was still regenerated
		newContent, err := os.ReadFile(generatedFilePath)
		require.NoError(t, err)
		assert.Contains(t, string(newContent), "type TestCase struct", "expected main file to be regenerated")
	})

	t.Run("default behavior (omitted) deletes old generated files", func(t *testing.T) {
		// Create config WITHOUT skip-delete-generated-files (should default to false)
		conjureYML := `version: 2
projects:
  test-project:
    output-dir: conjure-output3
    omit-top-level-project-dir: true
    ir-locator: ` + yamlDir + `
`
		err = os.WriteFile(filepath.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
		require.NoError(t, err)

		// First generation
		outputBuf := &bytes.Buffer{}
		runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
		require.NoError(t, err, outputBuf.String())
		runPluginCleanup()

		// Create an old file that should be deleted by default
		oldFilePath := filepath.Join(projectDir, "conjure-output3", "conjure", "test", "api", "oldfile.conjure.go")
		err = os.WriteFile(oldFilePath, []byte("// This is an old generated file\npackage api"), 0644)
		require.NoError(t, err)

		// Second generation - should delete old files (default behavior)
		outputBuf = &bytes.Buffer{}
		runPluginCleanup, err = pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
		require.NoError(t, err, outputBuf.String())
		runPluginCleanup()

		// Verify the old file was deleted (default is false)
		_, err = os.Stat(oldFilePath)
		assert.True(t, os.IsNotExist(err), "expected old conjure file to be deleted by default")
	})
}
