// Copyright (c) 2018 Palantir Technologies. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package integration_test

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"testing"

	"github.com/nmiyake/pkg/dirs"
	"github.com/palantir/godel-conjure-plugin/v6/internal/tempfilecreator"
	"github.com/palantir/godel/v2/framework/pluginapitester"
	"github.com/palantir/godel/v2/pkg/products"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestConjurePlugin(t *testing.T) {
	const (
		conjureSpecYML = `
types:
  definitions:
    default-package: com.palantir.conjure.test.api
    objects:
      TestCase:
        fields:
          name: string
      TestUnion:
        union:
          testCase: TestCase
`
		conjureSpecJSON = `
{
  "version" : 1,
  "errors" : [ ],
  "types" : [ {
    "type" : "object",
    "object" : {
      "typeName" : {
        "name" : "TestCase",
        "package" : "com.palantir.conjure.test.api"
      },
      "fields" : [ {
        "fieldName" : "name",
        "type" : {
          "type" : "primitive",
          "primitive" : "STRING"
        }
      } ]
    }
  } ],
  "services" : [ ]
}
`
		yamlDir              = "yamlDir"
		conjureYMLSubstitute = `
projects:
  project-1:
    accept-funcs: true
    output-dir: conjure-output
    ir-locator: ` + yamlDir + `
  project-2:
    output-dir: conjure-output2
    ir-locator:
      type: remote
      locator: SUBSTITUTE_URL
`
	)

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		_, _ = fmt.Fprint(w, conjureSpecJSON)
	}))
	defer ts.Close()

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := path.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()
	err = os.MkdirAll(path.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	conjureYML := strings.Replace(conjureYMLSubstitute, "SUBSTITUTE_URL", ts.URL, -1)
	err = ioutil.WriteFile(path.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
	require.NoError(t, err)

	err = ioutil.WriteFile(path.Join(ymlDir, "conjure.yml"), []byte(conjureSpecYML), 0644)
	require.NoError(t, err)

	outputBuf := &bytes.Buffer{}
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
	defer runPluginCleanup()
	require.NoError(t, err, outputBuf.String())

	for _, outputName := range []string{"conjure-output", "conjure-output2"} {
		contentBytes, err := ioutil.ReadFile(path.Join(projectDir, outputName, "conjure", "test", "api", "structs.conjure.go"))
		require.NoError(t, err)
		wantContent := `// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type TestCase struct {
	Name string ` + "`" + `json:"name"` + "`" + `
}

func (o TestCase) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *TestCase) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
`
		assert.Equal(t, wantContent, string(contentBytes), "Got:\n%s", string(contentBytes))
	}

	for _, outputName := range []string{"conjure-output"} {
		contentBytes, err := ioutil.ReadFile(path.Join(projectDir, outputName, "conjure", "test", "api", "unions.conjure.go"))
		require.NoError(t, err)
		wantContent := `// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"context"
	"fmt"

	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type TestUnion struct {
	typ      string
	testCase *TestCase
}

type testUnionDeserializer struct {
	Type     string    ` + "`" + `json:"type"` + "`" + `
	TestCase *TestCase ` + "`" + `json:"testCase"` + "`" + `
}

func (u *testUnionDeserializer) toStruct() TestUnion {
	return TestUnion{typ: u.Type, testCase: u.TestCase}
}

func (u *TestUnion) toSerializer() (interface{}, error) {
	switch u.typ {
	default:
		return nil, fmt.Errorf("unknown type %q", u.typ)
	case "testCase":
		if u.testCase == nil {
			return nil, fmt.Errorf("field \"testCase\" is required")
		}
		return struct {
			Type     string   ` + "`" + `json:"type"` + "`" + `
			TestCase TestCase ` + "`" + `json:"testCase"` + "`" + `
		}{Type: "testCase", TestCase: *u.testCase}, nil
	}
}

func (u TestUnion) MarshalJSON() ([]byte, error) {
	ser, err := u.toSerializer()
	if err != nil {
		return nil, err
	}
	return safejson.Marshal(ser)
}

func (u *TestUnion) UnmarshalJSON(data []byte) error {
	var deser testUnionDeserializer
	if err := safejson.Unmarshal(data, &deser); err != nil {
		return err
	}
	*u = deser.toStruct()
	switch u.typ {
	case "testCase":
		if u.testCase == nil {
			return fmt.Errorf("field \"testCase\" is required")
		}
	}
	return nil
}

func (u TestUnion) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(u)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (u *TestUnion) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&u)
}

func (u *TestUnion) AcceptFuncs(testCaseFunc func(TestCase) error, unknownFunc func(string) error) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in TestUnion type")
		}
		return unknownFunc(u.typ)
	case "testCase":
		if u.testCase == nil {
			return fmt.Errorf("field \"testCase\" is required")
		}
		return testCaseFunc(*u.testCase)
	}
}

func (u *TestUnion) TestCaseNoopSuccess(_ TestCase) error {
	return nil
}

func (u *TestUnion) ErrorOnUnknown(typeName string) error {
	return fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

func (u *TestUnion) Accept(v TestUnionVisitor) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(u.typ)
	case "testCase":
		if u.testCase == nil {
			return fmt.Errorf("field \"testCase\" is required")
		}
		return v.VisitTestCase(*u.testCase)
	}
}

type TestUnionVisitor interface {
	VisitTestCase(v TestCase) error
	VisitUnknown(typeName string) error
}

func (u *TestUnion) AcceptWithContext(ctx context.Context, v TestUnionVisitorWithContext) error {
	switch u.typ {
	default:
		if u.typ == "" {
			return fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknownWithContext(ctx, u.typ)
	case "testCase":
		if u.testCase == nil {
			return fmt.Errorf("field \"testCase\" is required")
		}
		return v.VisitTestCaseWithContext(ctx, *u.testCase)
	}
}

type TestUnionVisitorWithContext interface {
	VisitTestCaseWithContext(ctx context.Context, v TestCase) error
	VisitUnknownWithContext(ctx context.Context, typeName string) error
}

func NewTestUnionFromTestCase(v TestCase) TestUnion {
	return TestUnion{typ: "testCase", testCase: &v}
}
`
		assert.Equal(t, wantContent, string(contentBytes), "Got:\n%s", string(contentBytes))
	}
}

func TestConjurePluginVerify(t *testing.T) {
	const (
		conjureSpecYML = `
types:
  definitions:
    default-package: com.palantir.base.api
    objects:
      BaseType:
        fields:
          id: string
`
		yamlDir = "yamlDir"
	)

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := path.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()

	err = os.MkdirAll(path.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	err = ioutil.WriteFile(path.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(`
projects:
  project-1:
    output-dir: conjure
    ir-locator: `+yamlDir+`
`), 0644)
	require.NoError(t, err)

	err = ioutil.WriteFile(path.Join(ymlDir, "conjure.yml"), []byte(conjureSpecYML), 0644)
	require.NoError(t, err)

	outputBuf := &bytes.Buffer{}
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", nil, projectDir, false, outputBuf)
	defer runPluginCleanup()
	require.NoError(t, err, outputBuf.String())

	outputBuf = &bytes.Buffer{}
	_, err = pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", []string{"verify"}, projectDir, false, outputBuf)
	require.NoError(t, err, outputBuf.String())

	structsFile := filepath.Join("conjure", "base", "api", "structs.conjure.go")
	err = ioutil.WriteFile(filepath.Join(projectDir, structsFile), []byte("package api"), 0644)
	require.NoError(t, err, "failed to change generated file")

	outputBuf = &bytes.Buffer{}
	_, err = pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure", []string{"--verify"}, projectDir, false, outputBuf)
	assert.Error(t, err, "modified file did not trigger verify fail")
	stdout := outputBuf.String()
	assert.True(t, strings.Contains(stdout, structsFile+": checksum changed"), "Unexpected standard out: %s", stdout)
}

func TestConjurePluginPublish(t *testing.T) {
	const (
		conjureSpecYML = `
types:
  definitions:
    default-package: com.palantir.conjure.test.api
    objects:
      TestCase:
        fields:
          name: string
`
		yamlDir    = "yamlDir"
		conjureYML = `
projects:
  project-1:
    output-dir: conjure-output
    ir-locator: ` + yamlDir + `
`
		asset1 = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
    printf '%s\n' '{ "type": "conjure-ir-extensions-provider" }'
    exit 0
fi

printf '%s\n' '{}'
exit 0
`
	)

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))
	defer ts.Close()

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := path.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()
	err = os.MkdirAll(path.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	err = ioutil.WriteFile(path.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
	require.NoError(t, err)

	err = ioutil.WriteFile(path.Join(ymlDir, "conjure.yml"), []byte(conjureSpecYML), 0644)
	require.NoError(t, err)

	asset1File := tempfilecreator.MustWriteBytesToTempFile([]byte(asset1))
	require.NoError(t, os.Chmod(asset1File, 0700))

	outputBuf := &bytes.Buffer{}
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginapitester.NewPluginProvider(pluginPath), nil, "conjure-publish", []string{
		"--dry-run",
		"--assets=" + asset1File,
		"--group-id=com.palantir.test-group",
		"--repository=test-repo",
		"--url=" + ts.URL,
		"--username=test-username",
		"--password=test-password",
	}, projectDir, false, outputBuf)
	defer runPluginCleanup()
	require.NoError(t, err, outputBuf.String())

	lines := strings.Split(outputBuf.String(), "\n")
	assert.Equal(t, 3, len(lines), "Expected output to have 3 lines:\n%s", outputBuf.String())

	wantRegexp := regexp.QuoteMeta("[DRY RUN]") + " Uploading .*?" + regexp.QuoteMeta(".conjure.json") + " to " + regexp.QuoteMeta(ts.URL+"/artifactory/test-repo/com/palantir/test-group/project-1/") + ".*?" + regexp.QuoteMeta("/project-1-") + ".*?" + regexp.QuoteMeta(".conjure.json")
	assert.Regexp(t, wantRegexp, lines[0])

	wantRegexp = regexp.QuoteMeta("[DRY RUN]") + " Uploading to " + regexp.QuoteMeta(ts.URL+"/artifactory/test-repo/com/palantir/test-group/") + ".*?" + regexp.QuoteMeta(".pom")
	assert.Regexp(t, wantRegexp, lines[1])
}

func TestConjurePluginPublishAssetSpec(t *testing.T) {
	const (
		yamlDir    = "yamlDir"
		conjureYML = `
projects:
  project-1: { }
`
		assetDoesNotReturnValidJsonObject = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
    printf '%s\n' '{ "type": "conjure-ir-extensions-provider" }'
    exit 0
fi

printf '%s\n' '"not a json object"'
exit 0
`
		assetDoesNotReturnValidAssetInfoType = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
	touch /Volumes/git/ran-invalid-info
    printf '%s\n' '{ "Type": "conjure-ir-extensions-provider" }'
    exit 0
fi

printf '%s\n' 'unreachable: something is wrong if the asset was called with more anything other than _assetInfo as the only arg'
exit 1
`
		assetDoesNotReturnValidAssetInfoJson = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
	touch /Volumes/git/ran-invalid-info
    printf '%s\n' 'invalid json'
    exit 0
fi

printf '%s\n' 'unreachable: something is wrong if the asset was called with more anything other than _assetInfo as the only arg'
exit 1
`
		assetDoesNotReturnValidAssetInfoJsonObject = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
	touch /Volumes/git/ran-invalid-info
    printf '%s\n' '"invalid json object"'
    exit 0
fi

printf '%s\n' 'unreachable: something is wrong if the asset was called with more anything other than _assetInfo as the only arg'
exit 1
`
		assetDoesNotHaveValidType = `#!/bin/sh

if [ "$#" -ne 1 ]; then
    exit 1
fi

if [ "$1" = "_assetInfo" ]; then
    printf '%s\n' '{ "type": "valid type that follows the spec but is not supported yet so it should just not be called again and everything will exit OK" }'
    exit 0
fi

printf '%s\n' 'test failed: should be unreachable'
exit 1
`
	)

	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)

	projectDir, cleanup, err := dirs.TempDir(".", "")
	require.NoError(t, err)
	ymlDir := path.Join(projectDir, yamlDir)
	err = os.Mkdir(ymlDir, 0755)
	require.NoError(t, err)
	defer cleanup()
	err = os.MkdirAll(path.Join(projectDir, "godel", "config"), 0755)
	require.NoError(t, err)
	err = os.WriteFile(path.Join(projectDir, "godel", "config", "conjure-plugin.yml"), []byte(conjureYML), 0644)
	require.NoError(t, err)

	for _, assetFileContent := range []string{
		assetDoesNotReturnValidJsonObject,
		assetDoesNotReturnValidAssetInfoType,
		assetDoesNotReturnValidAssetInfoJson,
		assetDoesNotReturnValidAssetInfoJsonObject,
		assetDoesNotHaveValidType,
	} {
		assetFile := tempfilecreator.MustWriteBytesToTempFile([]byte(assetFileContent))
		require.NoError(t, os.Chmod(assetFile, 0700))

		err = innerTestConjurePluginPublishAssetSpec(pluginapitester.NewPluginProvider(pluginPath), assetFile, projectDir)
		assert.Error(t, err)
	}

}

func innerTestConjurePluginPublishAssetSpec(pluginProvider pluginapitester.PluginProvider, assetFile, projectDir string) error {
	runPluginCleanup, err := pluginapitester.RunPlugin(pluginProvider, nil, "conjure-publish", []string{
		"--dry-run",
		"--assets=" + assetFile,
		"--group-id=com.palantir.test-group",
		"--repository=test-repo",
		"--url=unreachable.palantir.com",
		"--username=test-username",
		"--password=test-password",
	}, projectDir, false, &bytes.Buffer{})
	defer runPluginCleanup()
	return err
}

func TestUpgradeConfig(t *testing.T) {
	pluginPath, err := products.Bin("conjure-plugin")
	require.NoError(t, err)
	pluginProvider := pluginapitester.NewPluginProvider(pluginPath)

	pluginapitester.RunUpgradeConfigTest(t,
		pluginProvider,
		nil,
		[]pluginapitester.UpgradeConfigTestCase{
			{
				Name: "legacy config fails to upgrade",
				ConfigFiles: map[string]string{
					"godel/config/conjure.yml": `
conjure-projects:
  # comment
  project-1:
    project-file: ./conjure-project.yml
  project-2:
    project-file: foo/conjure-project.yml
  project-3:
    project-file: bar/conjure-project.yml
`,
				},
				Legacy:     true,
				WantError:  true,
				WantOutput: "Failed to upgrade configuration:\n\tgodel/config/conjure-plugin.yml: failed to upgrade configuration: v0 configuration is not supported\n",
			},
			{
				Name: "blank legacy config upgrade succeeds",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": ``,
				},
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": ``,
				},
				Legacy:     true,
				WantOutput: "",
			},
			{
				Name: "v0 config fails to upgrade",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `
conjure-projects:
  # comment
  project-1:
    project-file: ./conjure-project.yml
  project-2:
    project-file: foo/conjure-project.yml
  project-3:
    project-file: bar/conjure-project.yml
`,
				},
				WantError:  true,
				WantOutput: "Failed to upgrade configuration:\n\tgodel/config/conjure-plugin.yml: v0 configuration is not supported\n",
			},
			{
				Name: "blank v0 config upgrade succeeds",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": ``,
				},
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": ``,
				},
				WantOutput: "",
			},
			{
				Name: "current config is unmodified",
				ConfigFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `
version: 1
projects:
  sls-health-api:
    # comment
    output-dir: conjure
    ir-locator: https://publish.artifactory.com/artifactory/internal-conjure-release/com/palantir/spec/health-api/3.2.0/health-api-3.2.0.json
`,
				},
				WantOutput: "",
				WantFiles: map[string]string{
					"godel/config/conjure-plugin.yml": `
version: 1
projects:
  sls-health-api:
    # comment
    output-dir: conjure
    ir-locator: https://publish.artifactory.com/artifactory/internal-conjure-release/com/palantir/spec/health-api/3.2.0/health-api-3.2.0.json
`,
				},
			},
		},
	)
}
