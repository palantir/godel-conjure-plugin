// Copyright (c) 2025 Palantir Technologies. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package conjureplugin

import (
	"bytes"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func Test_Run_Output(t *testing.T) {
	const (
		goModFileContent = `module conjure-test-module
`
		testConjureYAML = `types:
  definitions:
    default-package: com.palantir.base.api
    objects:
      BaseType:
        fields:
          id: string`
		generatedConjureFileContent = `// Code generated by conjure-go. DO NOT EDIT.

package api

import (
	"github.com/palantir/pkg/safejson"
	"github.com/palantir/pkg/safeyaml"
)

type BaseType struct {
	Id string ` + "`" + `json:"id"` + "`" + `
}

func (o BaseType) MarshalYAML() (interface{}, error) {
	jsonBytes, err := safejson.Marshal(o)
	if err != nil {
		return nil, err
	}
	return safeyaml.JSONtoYAMLMapSlice(jsonBytes)
}

func (o *BaseType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	jsonBytes, err := safeyaml.UnmarshalerToJSONBytes(unmarshal)
	if err != nil {
		return err
	}
	return safejson.Unmarshal(jsonBytes, *&o)
}
`
	)

	tmpDir := t.TempDir()
	err := os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte(goModFileContent), 0644)
	require.NoError(t, err)
	conjureFilePath := filepath.Join(tmpDir, "conjure.yml")
	err = os.WriteFile(conjureFilePath, []byte(testConjureYAML), 0644)
	require.NoError(t, err)

	for _, tc := range []struct {
		name       string
		setup      func(t *testing.T, projectDir string)
		wantErr    bool
		wantOutput string
	}{
		{
			name:    "verify fails for missing file",
			wantErr: true,
			wantOutput: `Conjure output differs from what currently exists for 1 project(s)
  test-project:
    output/base/api/structs.conjure.go: missing
`,
		},
		{
			name: "verify fails for file with incorrect checksum",
			setup: func(t *testing.T, projectDir string) {
				filePath := filepath.Join(projectDir, "output", "base", "api", "structs.conjure.go")
				err := os.MkdirAll(filepath.Dir(filePath), 0755)
				require.NoError(t, err)
				err = os.WriteFile(filePath, []byte(`dummy content`), 0644)
				require.NoError(t, err)
			},
			wantErr: true,
			wantOutput: `Conjure output differs from what currently exists for 1 project(s)
  test-project:
    output/base/api/structs.conjure.go: checksum changed from fb94eaea4461372a002dbda263dc6cf00f50f269cb30a7763fd975799b3763ee to bf0ecbdb9b814248d086c9b69cf26182d9d4138f2ad3d0637c4555fc8cbf68e5
`,
		},
		{
			name: "verify fails for extra file",
			setup: func(t *testing.T, projectDir string) {
				filePath := filepath.Join(projectDir, "output", "base", "api", "structs.conjure.go")
				err := os.MkdirAll(filepath.Dir(filePath), 0755)
				require.NoError(t, err)
				err = os.WriteFile(filePath, []byte(generatedConjureFileContent), 0644)
				require.NoError(t, err)

				filePath = filepath.Join(projectDir, "output", "base", "api", "extra.conjure.go")
				err = os.WriteFile(filePath, []byte("// Extra file"), 0644)
				require.NoError(t, err)
			},
			wantErr: true,
			wantOutput: `Conjure output differs from what currently exists for 1 project(s)
  test-project:
    output/base/api/extra.conjure.go: extra
`,
		},
		{
			name: "verify succeeds if state is correct",
			setup: func(t *testing.T, projectDir string) {
				filePath := filepath.Join(projectDir, "output", "base", "api", "structs.conjure.go")
				err := os.MkdirAll(filepath.Dir(filePath), 0755)
				require.NoError(t, err)
				err = os.WriteFile(filePath, []byte(generatedConjureFileContent), 0644)
				require.NoError(t, err)
			},
			wantOutput: ``,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			projectDir, err := os.MkdirTemp(tmpDir, "project-*")
			require.NoError(t, err)

			if tc.setup != nil {
				tc.setup(t, projectDir)
			}

			var out bytes.Buffer
			err = Run(ConjureProjectParams{
				{
					ProjectName: "test-project",
					OutputDir:   "output",
					IRProvider:  NewLocalYAMLIRProvider(conjureFilePath),
				},
			}, true, projectDir, &out)
			if tc.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			assert.Equal(t, tc.wantOutput, out.String())
		})
	}
}
