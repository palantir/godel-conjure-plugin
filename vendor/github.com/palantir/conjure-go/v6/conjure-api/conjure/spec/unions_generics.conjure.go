// Code generated by conjure-go. DO NOT EDIT.

//go:build go1.18

package spec

import (
	"context"
	"fmt"
)

type AuthTypeWithT[T any] AuthType

func (u *AuthTypeWithT[T]) Accept(ctx context.Context, v AuthTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "header":
		if u.header == nil {
			return result, fmt.Errorf("field \"header\" is required")
		}
		return v.VisitHeader(ctx, *u.header)
	case "cookie":
		if u.cookie == nil {
			return result, fmt.Errorf("field \"cookie\" is required")
		}
		return v.VisitCookie(ctx, *u.cookie)
	}
}

func (u *AuthTypeWithT[T]) AcceptFuncs(headerFunc func(HeaderAuthType) (T, error), cookieFunc func(CookieAuthType) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "header":
		if u.header == nil {
			return result, fmt.Errorf("field \"header\" is required")
		}
		return headerFunc(*u.header)
	case "cookie":
		if u.cookie == nil {
			return result, fmt.Errorf("field \"cookie\" is required")
		}
		return cookieFunc(*u.cookie)
	}
}

func (u *AuthTypeWithT[T]) HeaderNoopSuccess(HeaderAuthType) (T, error) {
	var result T
	return result, nil
}

func (u *AuthTypeWithT[T]) CookieNoopSuccess(CookieAuthType) (T, error) {
	var result T
	return result, nil
}

func (u *AuthTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type AuthTypeVisitorWithT[T any] interface {
	VisitHeader(ctx context.Context, v HeaderAuthType) (T, error)
	VisitCookie(ctx context.Context, v CookieAuthType) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type ParameterTypeWithT[T any] ParameterType

func (u *ParameterTypeWithT[T]) Accept(ctx context.Context, v ParameterTypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "body":
		if u.body == nil {
			return result, fmt.Errorf("field \"body\" is required")
		}
		return v.VisitBody(ctx, *u.body)
	case "header":
		if u.header == nil {
			return result, fmt.Errorf("field \"header\" is required")
		}
		return v.VisitHeader(ctx, *u.header)
	case "path":
		if u.path == nil {
			return result, fmt.Errorf("field \"path\" is required")
		}
		return v.VisitPath(ctx, *u.path)
	case "query":
		if u.query == nil {
			return result, fmt.Errorf("field \"query\" is required")
		}
		return v.VisitQuery(ctx, *u.query)
	}
}

func (u *ParameterTypeWithT[T]) AcceptFuncs(bodyFunc func(BodyParameterType) (T, error), headerFunc func(HeaderParameterType) (T, error), pathFunc func(PathParameterType) (T, error), queryFunc func(QueryParameterType) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "body":
		if u.body == nil {
			return result, fmt.Errorf("field \"body\" is required")
		}
		return bodyFunc(*u.body)
	case "header":
		if u.header == nil {
			return result, fmt.Errorf("field \"header\" is required")
		}
		return headerFunc(*u.header)
	case "path":
		if u.path == nil {
			return result, fmt.Errorf("field \"path\" is required")
		}
		return pathFunc(*u.path)
	case "query":
		if u.query == nil {
			return result, fmt.Errorf("field \"query\" is required")
		}
		return queryFunc(*u.query)
	}
}

func (u *ParameterTypeWithT[T]) BodyNoopSuccess(BodyParameterType) (T, error) {
	var result T
	return result, nil
}

func (u *ParameterTypeWithT[T]) HeaderNoopSuccess(HeaderParameterType) (T, error) {
	var result T
	return result, nil
}

func (u *ParameterTypeWithT[T]) PathNoopSuccess(PathParameterType) (T, error) {
	var result T
	return result, nil
}

func (u *ParameterTypeWithT[T]) QueryNoopSuccess(QueryParameterType) (T, error) {
	var result T
	return result, nil
}

func (u *ParameterTypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type ParameterTypeVisitorWithT[T any] interface {
	VisitBody(ctx context.Context, v BodyParameterType) (T, error)
	VisitHeader(ctx context.Context, v HeaderParameterType) (T, error)
	VisitPath(ctx context.Context, v PathParameterType) (T, error)
	VisitQuery(ctx context.Context, v QueryParameterType) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TypeWithT[T any] Type

func (u *TypeWithT[T]) Accept(ctx context.Context, v TypeVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "primitive":
		if u.primitive == nil {
			return result, fmt.Errorf("field \"primitive\" is required")
		}
		return v.VisitPrimitive(ctx, *u.primitive)
	case "optional":
		if u.optional == nil {
			return result, fmt.Errorf("field \"optional\" is required")
		}
		return v.VisitOptional(ctx, *u.optional)
	case "list":
		if u.list == nil {
			return result, fmt.Errorf("field \"list\" is required")
		}
		return v.VisitList(ctx, *u.list)
	case "set":
		if u.set == nil {
			return result, fmt.Errorf("field \"set\" is required")
		}
		return v.VisitSet(ctx, *u.set)
	case "map":
		if u.map_ == nil {
			return result, fmt.Errorf("field \"map\" is required")
		}
		return v.VisitMap(ctx, *u.map_)
	case "reference":
		if u.reference == nil {
			return result, fmt.Errorf("field \"reference\" is required")
		}
		return v.VisitReference(ctx, *u.reference)
	case "external":
		if u.external == nil {
			return result, fmt.Errorf("field \"external\" is required")
		}
		return v.VisitExternal(ctx, *u.external)
	}
}

func (u *TypeWithT[T]) AcceptFuncs(primitiveFunc func(PrimitiveType) (T, error), optionalFunc func(OptionalType) (T, error), listFunc func(ListType) (T, error), setFunc func(SetType) (T, error), map_Func func(MapType) (T, error), referenceFunc func(TypeName) (T, error), externalFunc func(ExternalReference) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "primitive":
		if u.primitive == nil {
			return result, fmt.Errorf("field \"primitive\" is required")
		}
		return primitiveFunc(*u.primitive)
	case "optional":
		if u.optional == nil {
			return result, fmt.Errorf("field \"optional\" is required")
		}
		return optionalFunc(*u.optional)
	case "list":
		if u.list == nil {
			return result, fmt.Errorf("field \"list\" is required")
		}
		return listFunc(*u.list)
	case "set":
		if u.set == nil {
			return result, fmt.Errorf("field \"set\" is required")
		}
		return setFunc(*u.set)
	case "map":
		if u.map_ == nil {
			return result, fmt.Errorf("field \"map\" is required")
		}
		return map_Func(*u.map_)
	case "reference":
		if u.reference == nil {
			return result, fmt.Errorf("field \"reference\" is required")
		}
		return referenceFunc(*u.reference)
	case "external":
		if u.external == nil {
			return result, fmt.Errorf("field \"external\" is required")
		}
		return externalFunc(*u.external)
	}
}

func (u *TypeWithT[T]) PrimitiveNoopSuccess(PrimitiveType) (T, error) {
	var result T
	return result, nil
}

func (u *TypeWithT[T]) OptionalNoopSuccess(OptionalType) (T, error) {
	var result T
	return result, nil
}

func (u *TypeWithT[T]) ListNoopSuccess(ListType) (T, error) {
	var result T
	return result, nil
}

func (u *TypeWithT[T]) SetNoopSuccess(SetType) (T, error) {
	var result T
	return result, nil
}

func (u *TypeWithT[T]) MapNoopSuccess(MapType) (T, error) {
	var result T
	return result, nil
}

func (u *TypeWithT[T]) ReferenceNoopSuccess(TypeName) (T, error) {
	var result T
	return result, nil
}

func (u *TypeWithT[T]) ExternalNoopSuccess(ExternalReference) (T, error) {
	var result T
	return result, nil
}

func (u *TypeWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TypeVisitorWithT[T any] interface {
	VisitPrimitive(ctx context.Context, v PrimitiveType) (T, error)
	VisitOptional(ctx context.Context, v OptionalType) (T, error)
	VisitList(ctx context.Context, v ListType) (T, error)
	VisitSet(ctx context.Context, v SetType) (T, error)
	VisitMap(ctx context.Context, v MapType) (T, error)
	VisitReference(ctx context.Context, v TypeName) (T, error)
	VisitExternal(ctx context.Context, v ExternalReference) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}

type TypeDefinitionWithT[T any] TypeDefinition

func (u *TypeDefinitionWithT[T]) Accept(ctx context.Context, v TypeDefinitionVisitorWithT[T]) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return v.VisitUnknown(ctx, u.typ)
	case "alias":
		if u.alias == nil {
			return result, fmt.Errorf("field \"alias\" is required")
		}
		return v.VisitAlias(ctx, *u.alias)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return v.VisitEnum(ctx, *u.enum)
	case "object":
		if u.object == nil {
			return result, fmt.Errorf("field \"object\" is required")
		}
		return v.VisitObject(ctx, *u.object)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return v.VisitUnion(ctx, *u.union)
	}
}

func (u *TypeDefinitionWithT[T]) AcceptFuncs(aliasFunc func(AliasDefinition) (T, error), enumFunc func(EnumDefinition) (T, error), objectFunc func(ObjectDefinition) (T, error), unionFunc func(UnionDefinition) (T, error), unknownFunc func(string) (T, error)) (T, error) {
	var result T
	switch u.typ {
	default:
		if u.typ == "" {
			return result, fmt.Errorf("invalid value in union type")
		}
		return unknownFunc(u.typ)
	case "alias":
		if u.alias == nil {
			return result, fmt.Errorf("field \"alias\" is required")
		}
		return aliasFunc(*u.alias)
	case "enum":
		if u.enum == nil {
			return result, fmt.Errorf("field \"enum\" is required")
		}
		return enumFunc(*u.enum)
	case "object":
		if u.object == nil {
			return result, fmt.Errorf("field \"object\" is required")
		}
		return objectFunc(*u.object)
	case "union":
		if u.union == nil {
			return result, fmt.Errorf("field \"union\" is required")
		}
		return unionFunc(*u.union)
	}
}

func (u *TypeDefinitionWithT[T]) AliasNoopSuccess(AliasDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *TypeDefinitionWithT[T]) EnumNoopSuccess(EnumDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *TypeDefinitionWithT[T]) ObjectNoopSuccess(ObjectDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *TypeDefinitionWithT[T]) UnionNoopSuccess(UnionDefinition) (T, error) {
	var result T
	return result, nil
}

func (u *TypeDefinitionWithT[T]) ErrorOnUnknown(typeName string) (T, error) {
	var result T
	return result, fmt.Errorf("invalid value in union type. Type name: %s", typeName)
}

type TypeDefinitionVisitorWithT[T any] interface {
	VisitAlias(ctx context.Context, v AliasDefinition) (T, error)
	VisitEnum(ctx context.Context, v EnumDefinition) (T, error)
	VisitObject(ctx context.Context, v ObjectDefinition) (T, error)
	VisitUnion(ctx context.Context, v UnionDefinition) (T, error)
	VisitUnknown(ctx context.Context, typ string) (T, error)
}
